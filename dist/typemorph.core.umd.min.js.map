{"version":3,"file":"typemorph.core.umd.min.js","sources":["../src/defaultConfigs.js","../src/helpers.js","../src/typemorph.js"],"sourcesContent":["export const defaultConfigs = {\r\n  text: null,\r\n  parent: null, // HTML element or string\r\n  speed: 50, // ms per character\r\n  chunkSize: 1,\r\n  loopCount: Infinity,\r\n  loopType: \"backspace\", // \"clear\" or \"backspace\"\r\n  loopFinalBehavior: \"keep\", // \"keep\" or \"remove\" -> removing type depends on loopType\r\n  loopStartDelay: 300, // ms to wait before typing again, after backspacing/clearing, in each loop (applies after first loop, meaning loop has to be > 1)\r\n  loopEndDelay: 800, // ms to wait after typing, before backspacing/clearing, in each loop (applies after first loop, meaning loop has to be > 1)\r\n  backspaceSpeed: 50, // speed per character when backspacing. Used when loopType is \"backspace\"\r\n  showCursor: true,\r\n  cursorChar: \"|\",\r\n  parseMarkdown: false, // if true, will parse makrdown syntax to HTML, meaning parseHtml is implied\r\n  markdownInline: false, // whether to parse markdown inline, can be helpful to avoid unwanted wrappers for simple text\r\n  parseHtml: true,\r\n  markdownParse: null, // custom markdown parse function -> markdownParse(text, inline = false)\r\n  hideCursorOnFinishTyping: true,\r\n  autoScroll: true,\r\n  scrollContainer: null, // custom scroll container. If not provided, the current typing parent is the target for autoscroll\r\n  scrollInterval: 1, // chunks typed before scroll is triggered when typing\r\n  smoothScroll: false, // instant scroll for reliable autoscroll for all speeds\r\n  clearBeforeTyping: true, // if type() was used on same parent, whether to clear text content before typing again\r\n  htmlSanitize: null, // custom html sanitize function -> htmlSanitize(html)\r\n  onStop: (instance) => {}, // typing has been stopped callback\r\n  onFinish: (instance) => {}, // typing naturally finished callback\r\n  onDestroy: (instance) => {}, // on instance destroy callback\r\n};\r\n","const CURSOR_CSS = `.typemorph-cursor {\r\n  display: inline-block;\r\n  animation: blink 1s step-start infinite;\r\n}\r\n\r\n@keyframes blink {\r\n  50% {\r\n    opacity: 0;\r\n  }\r\n}`;\r\n\r\nexport function injectCursorCSS() {\r\n  if (document.getElementById(\"typemorph-cursor-style\")) return;\r\n  const style = document.createElement(\"style\");\r\n  style.id = \"typemorph-cursor-style\";\r\n  style.textContent = CURSOR_CSS;\r\n  document.head.appendChild(style);\r\n}\r\n\r\nexport async function safeCallback(callback, ...args) {\r\n  if (typeof callback === \"function\") {\r\n    try {\r\n      const result = callback(...args);\r\n      if (result instanceof Promise) {\r\n        await result;\r\n      }\r\n    } catch (error) {\r\n      console.warn(\"TypeMorph: User callback error:\", error);\r\n    }\r\n  }\r\n}\r\n","import { defaultConfigs } from \"./defaultConfigs.js\";\r\nimport { injectCursorCSS, safeCallback } from \"./helpers.js\";\r\n\r\ninjectCursorCSS();\r\n\r\n/**\r\n * TypeMorph: Core typing animation\r\n * Handles typing, backspacing, and looping animations\r\n * Supports Markdown & HTML\r\n */\r\nexport default class TypeMorph {\r\n  constructor(config = {}) {\r\n    if (typeof document === \"undefined\") {\r\n      throw new Error(\"TypeMorph requires a DOM environment\");\r\n    }\r\n\r\n    this.config = { ...defaultConfigs, ...config };\r\n\r\n    if (this.config.parent) this._setParent(this.config.parent);\r\n    if (this.config.text) this._setText(this.config.text);\r\n    if (this.config.scrollContainer)\r\n      this._setScrollContainer(this.config.scrollContainer);\r\n\r\n    this.speed = this.config.speed;\r\n    this.backspaceSpeed = this.config.backspaceSpeed;\r\n    this.cursorChar = this.config.cursorChar;\r\n    this.chunkSize = this.config.chunkSize;\r\n    this.scrollInterval = this.config.scrollInterval;\r\n\r\n    this._currentLoop = 0;\r\n    this._cursorEl = null;\r\n    this._abortController = null;\r\n    this._destroyed = false;\r\n    this._isTyping = false;\r\n    this._operationQueue = Promise.resolve();\r\n    this._activeTimers = new Set();\r\n    this._userScrolled = false;\r\n    this._scrollListener = null;\r\n\r\n    this._validateOptions(this.config);\r\n  }\r\n\r\n  /**\r\n   * Type text character by character\r\n   * @param {string} text - Text to type\r\n   * @param {HTMLElement|string} parent - Parent element or selector\r\n   * @param {object} options - Additional options to override instance config for current operation\r\n   */\r\n  async type(text, parent = null, options = {}) {\r\n    this._checkLifetime();\r\n    const { _parent, _options } = this._readOptions(parent, options);\r\n    this._validateOptions(_options);\r\n    await this._cancelCurrentOperation(_options);\r\n    return this._startOperation(async (signal) => {\r\n      this._createCursor(_options);\r\n      await this._type(\r\n        text,\r\n        _parent,\r\n        { ..._options, loopSource: false },\r\n        signal\r\n      );\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Stop current operation\r\n   */\r\n  async stop() {\r\n    this._checkLifetime();\r\n    await this._cancelCurrentOperation();\r\n    await safeCallback(this.config.onStop, this);\r\n  }\r\n\r\n  /**\r\n   * Loop typing animation\r\n   * @param {string} text - Text to type in loop\r\n   * @param {HTMLElement|string} parent - Parent element or selector\r\n   * @param {object} options - Additional options to override instance config for current operation\r\n   */\r\n  async loop(text = null, parent = null, options = {}) {\r\n    this._checkLifetime();\r\n    const { _parent, _options } = this._readOptions(parent, options);\r\n    this._validateOptions(_options);\r\n    await this._cancelCurrentOperation(_options);\r\n    return this._startOperation(async (signal) => {\r\n      await this._loop(text, _parent, signal, _options);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Backspace animation\r\n   * @param {number} count - Number of characters to backspace\r\n   * @param {HTMLElement|string} parent - Parent element or selector\r\n   * @param {object} options - Additional options to override instance config for current operation\r\n   */\r\n  async backspace(count = null, parent = null, options = {}) {\r\n    this._checkLifetime();\r\n    const { _parent, _options } = this._readOptions(parent, options);\r\n    this._validateOptions(_options);\r\n    const targetParent = this._resolveParent(_parent);\r\n    _options.scrollContainer = this._getScrollContainer(targetParent, _options);\r\n    this._setupScrollTracking(_options.scrollContainer);\r\n\r\n    if (count != null && (typeof count != \"number\" || count < 0))\r\n      throw new Error(\"TypeMorph: count has to be a number >= 0\");\r\n\r\n    await this._cancelCurrentOperation(_options);\r\n    return this._startOperation(async (signal) => {\r\n      this._createCursor(_options);\r\n\r\n      try {\r\n        this._isTyping = true;\r\n\r\n        await this._backspaceContent(targetParent, targetParent, signal, {\r\n          ..._options,\r\n          maxDeleteCount: count,\r\n        });\r\n      } finally {\r\n        this._isTyping = false;\r\n        if (!signal.aborted) {\r\n          await this._onFinish(_options);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Destroy the instance and cleanup\r\n   */\r\n  destroy() {\r\n    if (this._destroyed) return;\r\n\r\n    this.stop();\r\n    this._abortController = null;\r\n    this._removeCursor();\r\n    this._clearScrollListener();\r\n    this._destroyed = true;\r\n\r\n    safeCallback(this.config.onDestroy, this);\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @returns {boolean} - Whether the instance is currently typing\r\n   */\r\n  isTyping() {\r\n    return this._isTyping;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @returns {boolean} - Whether the instance is destroyed\r\n   */\r\n  isDestroyed() {\r\n    return this._destroyed;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @returns {number} - Current loop iteration (0-based)\r\n   */\r\n  getCurrentLoop() {\r\n    return this._currentLoop;\r\n  }\r\n\r\n  async _loop(text, parent, signal, options) {\r\n    this._createCursor(options);\r\n    this._currentLoop = 0;\r\n    this._isTyping = true;\r\n\r\n    const targetParent = this._resolveParent(parent);\r\n    const targetText = this._resolveText(text);\r\n\r\n    const clearBeforeTyping =\r\n      options?.clearBeforeTyping ?? this.config.clearBeforeTyping;\r\n    const loopStartDelay =\r\n      options?.loopStartDelay ?? this.config.loopStartDelay;\r\n    const loopEndDelay = options?.loopEndDelay ?? this.config.loopEndDelay;\r\n    const loopType = options?.loopType ?? this.config.loopType;\r\n    const loopCount = options?.loopCount ?? this.config.loopCount;\r\n    const loopFinalBehavior =\r\n      options?.loopFinalBehavior ?? this.config.loopFinalBehavior;\r\n\r\n    options.scrollContainer = this._getScrollContainer(targetParent, options);\r\n\r\n    if (clearBeforeTyping) {\r\n      this._clearContent(targetParent);\r\n    }\r\n\r\n    this._setupScrollTracking(options.scrollContainer);\r\n\r\n    try {\r\n      do {\r\n        if (signal.aborted) break;\r\n\r\n        const willStillBeLooping =\r\n          this._currentlyLooping(targetParent) &&\r\n          this._currentLoop < loopCount - 1;\r\n        const isFinalLoop =\r\n          this._currentlyLooping(targetParent) &&\r\n          this._currentLoop + 1 >= loopCount;\r\n\r\n        if (\r\n          this._currentlyLooping(targetParent) &&\r\n          this._currentLoop > 0 &&\r\n          loopStartDelay\r\n        ) {\r\n          await this._delay(loopStartDelay, signal);\r\n        }\r\n\r\n        await this._type(\r\n          targetText,\r\n          targetParent,\r\n          { ...options, loopSource: true },\r\n          signal\r\n        );\r\n\r\n        if (signal.aborted) break;\r\n\r\n        const willClear =\r\n          this._currentlyLooping(targetParent) &&\r\n          (willStillBeLooping ||\r\n            (isFinalLoop && loopFinalBehavior === \"remove\"));\r\n\r\n        if (willClear && loopEndDelay) {\r\n          await this._delay(loopEndDelay, signal);\r\n        }\r\n\r\n        if (willClear) {\r\n          if (loopType === \"clear\") {\r\n            this._clearContent(targetParent);\r\n          } else {\r\n            await this._backspaceContent(targetParent, targetParent, signal, {\r\n              ...options,\r\n              maxDeleteCount: null,\r\n            });\r\n          }\r\n        }\r\n\r\n        this._currentLoop++;\r\n      } while (\r\n        this._currentlyLooping(targetParent) &&\r\n        this._currentLoop < loopCount &&\r\n        !signal.aborted\r\n      );\r\n\r\n      if (!signal.aborted) {\r\n        await this._onFinish(options);\r\n      }\r\n    } finally {\r\n      this._isTyping = false;\r\n    }\r\n  }\r\n\r\n  async _type(text, parent, options, signal) {\r\n    const targetParent = options.loopSource\r\n      ? parent\r\n      : this._resolveParent(parent);\r\n    const targetText = options.loopSource ? text : this._resolveText(text);\r\n\r\n    options.scrollContainer = options.loopSource\r\n      ? options.scrollContainer\r\n      : this._getScrollContainer(targetParent, options);\r\n\r\n    if (!options.loopSource) this._setupScrollTracking(options.scrollContainer);\r\n\r\n    this._isTyping = true;\r\n\r\n    const parseMarkdown = options?.parseMarkdown ?? this.config.parseMarkdown;\r\n    const parseHtml = options?.parseHtml ?? this.config.parseHtml;\r\n    const clearBeforeTyping =\r\n      options?.clearBeforeTyping ?? this.config.clearBeforeTyping;\r\n    const markdownInline =\r\n      options?.markdownInline ?? this.config.markdownInline;\r\n    const markdownParse = options?.markdownParse ?? this.config.markdownParse;\r\n\r\n    if (clearBeforeTyping && !options?.loopSource && !signal.aborted) {\r\n      this._clearContent(targetParent);\r\n    }\r\n\r\n    try {\r\n      let contentToType = targetText;\r\n\r\n      if (parseMarkdown) {\r\n        const parseMethod = markdownInline ? \"parseInline\" : \"parse\";\r\n\r\n        const result = markdownParse\r\n          ? markdownParse(contentToType, markdownInline)\r\n          : (await getDeps()).marked[parseMethod](contentToType);\r\n\r\n        contentToType = result instanceof Promise ? await result : result;\r\n      }\r\n\r\n      if (parseHtml || parseMarkdown) {\r\n        await this._typeHTML(contentToType, targetParent, signal, options);\r\n      } else {\r\n        await this._typeText(contentToType, targetParent, signal, options);\r\n      }\r\n\r\n      if (!options?.loopSource && !signal.aborted) {\r\n        await this._onFinish(options);\r\n      }\r\n    } finally {\r\n      if (!options?.loopSource) {\r\n        this._isTyping = false;\r\n      }\r\n    }\r\n  }\r\n\r\n  _createCursor(options = {}) {\r\n    const showCursor = options?.showCursor ?? this.config.showCursor;\r\n    const cursorChar = options?.cursorChar ?? this.cursorChar;\r\n\r\n    if (!showCursor) {\r\n      this._removeCursor();\r\n      return;\r\n    }\r\n\r\n    if (this._cursorEl) {\r\n      this._cursorEl.textContent = cursorChar;\r\n      return;\r\n    }\r\n\r\n    this._cursorEl = document.createElement(\"span\");\r\n    this._cursorEl.textContent = cursorChar;\r\n    this._cursorEl.className = \"typemorph-cursor\";\r\n    this._cursorEl.setAttribute(\"data-typemorph-cursor\", \"true\");\r\n  }\r\n\r\n  async _typeHTML(html, parent, signal, options) {\r\n    const htmlSanitize = options?.htmlSanitize ?? this.config.htmlSanitize;\r\n    const result = htmlSanitize\r\n      ? htmlSanitize(html)\r\n      : (await getDeps()).DOMPurify.sanitize(html);\r\n\r\n    html = result instanceof Promise ? await result : result;\r\n\r\n    const parser = new DOMParser();\r\n    const doc = parser.parseFromString(html, \"text/html\");\r\n    await this._typeNode(parent, doc.body, signal, options);\r\n  }\r\n\r\n  async _typeNode(parent, node, signal, options) {\r\n    const children = Array.from(node.childNodes);\r\n\r\n    for (let child of children) {\r\n      if (signal.aborted || !this._parentStillExists(parent)) break;\r\n\r\n      if (\r\n        child.nodeType === Node.TEXT_NODE &&\r\n        child.textContent.trim().length > 0\r\n      ) {\r\n        await this._typeText(child.textContent, parent, signal, options);\r\n      } else if (child.nodeType === Node.ELEMENT_NODE) {\r\n        const el = document.createElement(child.tagName);\r\n\r\n        for (let attr of child.attributes) {\r\n          try {\r\n            el.setAttribute(attr.name, attr.value);\r\n          } catch (e) {\r\n            console.warn(\"TypeMorph: Failed to set attribute\", attr.name, e);\r\n          }\r\n        }\r\n\r\n        parent.appendChild(el);\r\n        await this._typeNode(el, child, signal, options);\r\n      }\r\n    }\r\n  }\r\n\r\n  async _typeText(text, parent, signal, options) {\r\n    if (!text || signal.aborted || !this._parentStillExists(parent)) return;\r\n\r\n    if (this._cursorEl) {\r\n      if (this._cursorEl.parentNode) {\r\n        this._cursorEl.remove();\r\n      }\r\n      parent.appendChild(this._cursorEl);\r\n    }\r\n\r\n    const chars = Array.from(text);\r\n    let buffer = \"\";\r\n    let scrollCounter = 0;\r\n\r\n    const speed = options?.speed ?? this.speed;\r\n    const autoScroll = options?.autoScroll ?? this.config.autoScroll;\r\n    const scrollInterval = options?.scrollInterval ?? this.scrollInterval;\r\n    const chunkSize = options?.chunkSize ?? this.chunkSize;\r\n\r\n    for (let i = 0; i < chars.length; i++) {\r\n      if (signal.aborted || !this._parentStillExists(parent)) break;\r\n\r\n      buffer += chars[i];\r\n\r\n      const append = buffer.length >= chunkSize || i === chars.length - 1;\r\n      if (append) {\r\n        this._appendTextToParent(parent, buffer);\r\n        buffer = \"\";\r\n        scrollCounter++;\r\n        if (autoScroll && scrollCounter >= scrollInterval) {\r\n          this._scrollToEnd(options.scrollContainer);\r\n          scrollCounter = 0;\r\n        }\r\n      }\r\n\r\n      if (this._parentStillExists(parent) && append)\r\n        await this._delay(speed, signal);\r\n    }\r\n\r\n    if (autoScroll) {\r\n      this._scrollToEnd(options.scrollContainer);\r\n    }\r\n  }\r\n\r\n  _appendTextToParent(parent, text) {\r\n    if (!this._parentStillExists(parent)) return;\r\n\r\n    if (this._cursorEl) {\r\n      let previousSibling = this._cursorEl.previousSibling;\r\n      if (previousSibling && previousSibling.nodeType === Node.TEXT_NODE) {\r\n        previousSibling.textContent += text;\r\n      } else {\r\n        const newTextNode = document.createTextNode(text);\r\n        parent.insertBefore(newTextNode, this._cursorEl);\r\n      }\r\n    } else {\r\n      if (parent.lastChild && parent.lastChild.nodeType === Node.TEXT_NODE) {\r\n        parent.lastChild.textContent += text;\r\n      } else {\r\n        const newTextNode = document.createTextNode(text);\r\n        parent.appendChild(newTextNode);\r\n      }\r\n    }\r\n  }\r\n\r\n  async _onFinish(options) {\r\n    this._clearCursorIfNeeded(options);\r\n    await safeCallback(options?.onFinish ?? this.config.onFinish, this);\r\n  }\r\n\r\n  _clearContent(parent) {\r\n    parent.innerHTML = \"\";\r\n    if (this._cursorEl) parent.appendChild(this._cursorEl);\r\n  }\r\n\r\n  _clearCursorIfNeeded(options = {}) {\r\n    if (\r\n      options?.hideCursorOnFinishTyping ??\r\n      this.config.hideCursorOnFinishTyping\r\n    ) {\r\n      this._removeCursor();\r\n    }\r\n  }\r\n\r\n  _removeCursor() {\r\n    if (this._cursorEl) {\r\n      this._cursorEl.remove();\r\n      this._cursorEl = null;\r\n    }\r\n  }\r\n\r\n  async _backspaceContent(parent, node, signal, options, state = {}) {\r\n    if (!state.charDeleteCount) state.charDeleteCount = 0;\r\n    if (signal.aborted || !this._parentStillExists(parent)) return;\r\n\r\n    const children = Array.from(node.childNodes);\r\n\r\n    for (let i = children.length - 1; i >= 0; i--) {\r\n      const child = children[i];\r\n      if (signal.aborted || !this._parentStillExists(parent)) return;\r\n\r\n      if (this._cursorEl && child === this._cursorEl) {\r\n        continue;\r\n      }\r\n\r\n      if (child.nodeType === Node.TEXT_NODE) {\r\n        const { charDeleteCount } = await this._backspaceTextNode(\r\n          child,\r\n          parent,\r\n          signal,\r\n          options\r\n        );\r\n\r\n        state.charDeleteCount += charDeleteCount;\r\n        if (\r\n          options.maxDeleteCount &&\r\n          state.charDeleteCount >= options.maxDeleteCount\r\n        )\r\n          break;\r\n      } else if (child.nodeType === Node.ELEMENT_NODE) {\r\n        if (\r\n          options.maxDeleteCount &&\r\n          state.charDeleteCount >= options.maxDeleteCount\r\n        )\r\n          break;\r\n\r\n        await this._backspaceContent(parent, child, signal, options, state);\r\n\r\n        if (!signal.aborted) {\r\n          child.parentNode.removeChild(child);\r\n          if (this._cursorEl) {\r\n            this._appendCursorToLastTextNode(parent);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    this._cleanEmptyTextNodes(parent);\r\n  }\r\n\r\n  _appendCursorToLastTextNode(parent) {\r\n    const lastTextNode = this._findLastTextNode(parent);\r\n    if (lastTextNode && lastTextNode.parentNode) {\r\n      lastTextNode.parentNode.appendChild(this._cursorEl);\r\n    } else {\r\n      parent.appendChild(this._cursorEl);\r\n    }\r\n  }\r\n\r\n  _findLastTextNode(element) {\r\n    const childNodes = Array.from(element.childNodes);\r\n\r\n    for (let i = childNodes.length - 1; i >= 0; i--) {\r\n      const child = childNodes[i];\r\n      if (child == this._cursorEl) continue;\r\n      if (child.nodeType === Node.TEXT_NODE) {\r\n        if (child.textContent && child.textContent.trim().length > 0) {\r\n          return child;\r\n        }\r\n      } else if (child.nodeType === Node.ELEMENT_NODE) {\r\n        const lastTextInChild = this._findLastTextNode(child);\r\n        if (lastTextInChild) {\r\n          return lastTextInChild;\r\n        }\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  _cleanEmptyTextNodes(parent) {\r\n    const children = Array.from(parent.childNodes);\r\n    children.forEach((child) => {\r\n      if (\r\n        child.nodeType === Node.TEXT_NODE &&\r\n        (!child.textContent || child.textContent.trim().length === 0)\r\n      ) {\r\n        child.parentNode.removeChild(child);\r\n      }\r\n    });\r\n  }\r\n\r\n  async _backspaceTextNode(node, parent, signal, options) {\r\n    const chars = Array.from(node.textContent);\r\n    let charDeleteCount = 0;\r\n    let scrollCounter = 0;\r\n\r\n    const chunkSize = options?.chunkSize ?? this.config.chunkSize;\r\n    const autoScroll = options?.autoScroll ?? this.config.autoScroll;\r\n\r\n    for (let i = chars.length - 1; i >= 0; i -= chunkSize) {\r\n      if (signal.aborted || !this._parentStillExists(parent)) break;\r\n\r\n      const chunkStart = Math.max(0, i - chunkSize + 1);\r\n      const charsToKeep = chars.slice(0, chunkStart);\r\n      const scrollInterval = options?.scrollInterval ?? this.scrollInterval;\r\n      const backspaceSpeed = options?.backspaceSpeed ?? this.backspaceSpeed;\r\n\r\n      node.textContent = charsToKeep.join(\"\");\r\n      charDeleteCount += i - chunkStart + 1;\r\n\r\n      scrollCounter++;\r\n      if (autoScroll && scrollCounter >= scrollInterval) {\r\n        if (node.parentNode) {\r\n          this._scrollToEnd(options.scrollContainer);\r\n        }\r\n        scrollCounter = 0;\r\n      }\r\n\r\n      if (this._parentStillExists(parent))\r\n        await this._delay(backspaceSpeed, signal);\r\n\r\n      if (options.maxDeleteCount && charDeleteCount >= options.maxDeleteCount)\r\n        break;\r\n    }\r\n\r\n    if (\r\n      this._parentStillExists(parent) &&\r\n      node.parentNode &&\r\n      !node.textContent\r\n    ) {\r\n      node.parentNode.removeChild(node);\r\n    }\r\n\r\n    if (autoScroll && this._parentStillExists(parent) && node.parentNode) {\r\n      this._scrollToEnd(options.scrollContainer);\r\n    }\r\n\r\n    return { charDeleteCount };\r\n  }\r\n\r\n  _resolveParent(parent = null) {\r\n    return this._validateElement(parent ?? this.parent);\r\n  }\r\n\r\n  _getScrollContainer(currentParent, options) {\r\n    if (options?.scrollContainer)\r\n      this._validateElement(options.scrollContainer);\r\n    return this.scrollContainer ?? currentParent;\r\n  }\r\n\r\n  _setParent(parent) {\r\n    this.parent = this._validateElement(parent);\r\n  }\r\n\r\n  _setScrollContainer(element) {\r\n    this.scrollContainer = this._validateElement(element);\r\n  }\r\n\r\n  _validateElement(element) {\r\n    const htmlEl = this._getElement(element);\r\n    const isHtmlElement = htmlEl instanceof Element;\r\n\r\n    if (!htmlEl || !isHtmlElement) {\r\n      if (typeof element === \"string\") {\r\n        throw new Error(\r\n          `TypeMorph: Element not found for selector #${element}`\r\n        );\r\n      } else {\r\n        throw new Error(\r\n          `TypeMorph: Element is not a valid HTML element or element ID`\r\n        );\r\n      }\r\n    }\r\n\r\n    return htmlEl;\r\n  }\r\n\r\n  _getElement(element) {\r\n    return typeof element === \"string\"\r\n      ? document.getElementById(element)\r\n      : element;\r\n  }\r\n\r\n  _resolveText(text = null) {\r\n    return this._validateText(text ?? this.text);\r\n  }\r\n\r\n  _setText(text) {\r\n    this.text = this._validateText(text);\r\n  }\r\n\r\n  _validateText(text) {\r\n    if (text == null) {\r\n      throw new Error(\"[TypeMorph] Please provide a valid text\");\r\n    }\r\n\r\n    if (typeof text !== \"string\") {\r\n      console.warn(\r\n        `[TypeMorph] Non-string input (${typeof text}) auto-converted to string.`\r\n      );\r\n      text = String(text);\r\n    }\r\n\r\n    return text;\r\n  }\r\n\r\n  _currentlyLooping(parent) {\r\n    return this._isTyping && this._parentStillExists(parent);\r\n  }\r\n\r\n  _checkLifetime() {\r\n    if (this._destroyed) {\r\n      throw new Error(\"TypeMorph: Cannot call method on destroyed instance\");\r\n    }\r\n  }\r\n\r\n  async _delay(ms, signal) {\r\n    return new Promise((resolve) => {\r\n      const timer = setTimeout(() => {\r\n        this._activeTimers.delete(timer);\r\n        resolve();\r\n      }, ms);\r\n\r\n      this._activeTimers.add(timer);\r\n\r\n      signal.addEventListener(\r\n        \"abort\",\r\n        () => {\r\n          clearTimeout(timer);\r\n          this._activeTimers.delete(timer);\r\n          resolve();\r\n        },\r\n        { once: true }\r\n      );\r\n    });\r\n  }\r\n\r\n  async _startOperation(operation) {\r\n    if (this._abortController) {\r\n      this._abortController.abort();\r\n    }\r\n\r\n    const controller = new AbortController();\r\n    this._abortController = controller;\r\n\r\n    this._operationQueue = (async () => {\r\n      try {\r\n        await operation(controller.signal);\r\n      } catch (err) {\r\n        if (err.name !== \"AbortError\") throw err;\r\n      } finally {\r\n        if (this._abortController === controller) {\r\n          this._abortController = null;\r\n        }\r\n        this._clearScrollListener();\r\n      }\r\n    })();\r\n\r\n    return this._operationQueue;\r\n  }\r\n\r\n  async _cancelCurrentOperation(options = {}) {\r\n    if (this._abortController) {\r\n      this._abortController.abort();\r\n    }\r\n\r\n    if (this._operationQueue) {\r\n      try {\r\n        await this._operationQueue;\r\n      } catch {}\r\n    }\r\n\r\n    this._isTyping = false;\r\n    this._clearCursorIfNeeded(options);\r\n    this._clearScrollListener();\r\n  }\r\n\r\n  _parentStillExists(parent) {\r\n    return parent && parent.isConnected;\r\n  }\r\n\r\n  _validateOptions(options) {\r\n    if (!options) return;\r\n\r\n    if (\r\n      (options.chunkSize != null && typeof options.chunkSize != \"number\") ||\r\n      options.chunkSize < 1\r\n    )\r\n      throw new Error(\"TypeMorph: chunkSize has to be a number > 0\");\r\n\r\n    if (\r\n      (options.loopCount != null && typeof options.loopCount != \"number\") ||\r\n      options.loopCount < 0\r\n    )\r\n      throw new Error(\"TypeMorph: loopCount has to be a number >= 0\");\r\n\r\n    if (\r\n      (options.speed != null && typeof options.speed != \"number\") ||\r\n      options.speed < 0\r\n    )\r\n      throw new Error(\"TypeMorph: speed has to be a number >= 0\");\r\n\r\n    if (\r\n      (options.backspaceSpeed != null &&\r\n        typeof options.backspaceSpeed != \"number\") ||\r\n      options.backspaceSpeed < 0\r\n    )\r\n      throw new Error(\"TypeMorph: backspaceSpeed has to be a number >= 0\");\r\n  }\r\n\r\n  _readOptions(_parent, _options) {\r\n    if (_parent && typeof _parent === \"object\" && !(\"nodeType\" in _parent)) {\r\n      _options = _parent;\r\n      _parent = null;\r\n    }\r\n    return { _parent, _options };\r\n  }\r\n\r\n  _scrollToEnd(parent) {\r\n    if (parent.scrollHeight <= parent.clientHeight) return;\r\n    if (this._userScrolled) return;\r\n    if (this.config.smoothScroll) {\r\n      parent.scrollTo({\r\n        top: parent.scrollHeight - parent.clientHeight,\r\n        behavior: \"smooth\",\r\n      });\r\n    } else {\r\n      parent.scrollTop = parent.scrollHeight - parent.clientHeight;\r\n    }\r\n  }\r\n\r\n  _setupScrollTracking(parent) {\r\n    this._clearScrollListener();\r\n\r\n    const handler = () => {\r\n      const distanceToBottom =\r\n        parent.scrollHeight - parent.scrollTop - parent.clientHeight;\r\n      this._userScrolled = distanceToBottom > 0;\r\n    };\r\n\r\n    parent.addEventListener(\"scroll\", handler, { passive: true });\r\n    this._scrollListener = { element: parent, handler };\r\n  }\r\n\r\n  _clearScrollListener() {\r\n    if (this._scrollListener) {\r\n      this._scrollListener.element.removeEventListener(\r\n        \"scroll\",\r\n        this._scrollListener.handler\r\n      );\r\n      this._scrollListener = null;\r\n    }\r\n    this._userScrolled = false;\r\n  }\r\n}\r\n\r\nlet loadedDeps = null;\r\nasync function getDeps() {\r\n  if (loadedDeps) return loadedDeps;\r\n\r\n  try {\r\n    const markedLib = await import(\"marked\");\r\n    const DOMPurify = (await import(\"dompurify\")).default;\r\n\r\n    loadedDeps = { marked: markedLib.marked, DOMPurify };\r\n    return loadedDeps;\r\n  } catch (error) {\r\n    console.error(\r\n      \"Failed to load dependencies, you may be using the Core version of the library. In that case, eithter turn off markdown and html parsing or provide your own parser and sanitizer\"\r\n    );\r\n    throw error;\r\n  }\r\n}\r\n"],"names":["defaultConfigs","text","parent","speed","chunkSize","loopCount","Infinity","loopType","loopFinalBehavior","loopStartDelay","loopEndDelay","backspaceSpeed","showCursor","cursorChar","parseMarkdown","markdownInline","parseHtml","markdownParse","hideCursorOnFinishTyping","autoScroll","scrollContainer","scrollInterval","smoothScroll","clearBeforeTyping","htmlSanitize","onStop","instance","onFinish","onDestroy","async","safeCallback","callback","args","result","Promise","error","console","warn","document","getElementById","style","createElement","id","textContent","head","appendChild","injectCursorCSS","loadedDeps","getDeps","markedLib","import","DOMPurify","default","marked","constructor","config","Error","this","_setParent","_setText","_setScrollContainer","_currentLoop","_cursorEl","_abortController","_destroyed","_isTyping","_operationQueue","resolve","_activeTimers","Set","_userScrolled","_scrollListener","_validateOptions","type","options","_checkLifetime","_parent","_options","_readOptions","_cancelCurrentOperation","_startOperation","signal","_createCursor","_type","loopSource","stop","loop","_loop","backspace","count","targetParent","_resolveParent","_getScrollContainer","_setupScrollTracking","_backspaceContent","maxDeleteCount","aborted","_onFinish","destroy","_removeCursor","_clearScrollListener","isTyping","isDestroyed","getCurrentLoop","targetText","_resolveText","_clearContent","willStillBeLooping","_currentlyLooping","isFinalLoop","_delay","willClear","contentToType","parseMethod","_typeHTML","_typeText","className","setAttribute","html","sanitize","doc","DOMParser","parseFromString","_typeNode","body","node","children","Array","from","childNodes","child","_parentStillExists","nodeType","Node","TEXT_NODE","trim","length","ELEMENT_NODE","el","tagName","attr","attributes","name","value","e","parentNode","remove","chars","buffer","scrollCounter","i","append","_appendTextToParent","_scrollToEnd","previousSibling","newTextNode","createTextNode","insertBefore","lastChild","_clearCursorIfNeeded","innerHTML","state","charDeleteCount","_backspaceTextNode","removeChild","_appendCursorToLastTextNode","_cleanEmptyTextNodes","lastTextNode","_findLastTextNode","element","lastTextInChild","forEach","chunkStart","Math","max","charsToKeep","slice","join","_validateElement","currentParent","htmlEl","_getElement","isHtmlElement","Element","_validateText","String","ms","timer","setTimeout","delete","add","addEventListener","clearTimeout","once","operation","abort","controller","AbortController","err","isConnected","scrollHeight","clientHeight","scrollTo","top","behavior","scrollTop","handler","distanceToBottom","passive","removeEventListener"],"mappings":"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"}