!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).TypeMorph=e()}(this,function(){"use strict";const t={text:null,parent:null,speed:50,chunkSize:1,loopCount:1/0,loopType:"backspace",loopFinalBehavior:"keep",loopStartDelay:300,loopEndDelay:800,backspaceSpeed:50,showCursor:!0,cursorChar:"|",parseMarkdown:!1,markdownInline:!1,parseHtml:!0,markdownParse:null,hideCursorOnFinishTyping:!0,autoScroll:!0,scrollContainer:null,scrollInterval:1,smoothScroll:!1,clearBeforeTyping:!0,htmlSanitize:null,onStop:t=>{},onFinish:t=>{},onDestroy:t=>{}};async function e(t,...e){if("function"==typeof t)try{const r=t(...e);r instanceof Promise&&await r}catch(t){console.warn("TypeMorph: User callback error:",t)}}!function(){if(document.getElementById("typemorph-cursor-style"))return;const t=document.createElement("style");t.id="typemorph-cursor-style",t.textContent=".typemorph-cursor {\n  display: inline-block;\n  animation: blink 1s step-start infinite;\n}\n\n@keyframes blink {\n  50% {\n    opacity: 0;\n  }\n}",document.head.appendChild(t)}();let r=null;async function o(){if(r)return r;try{const t=await import("marked"),e=(await import("dompurify")).default;return r={marked:t.marked,DOMPurify:e},r}catch(t){throw console.error("Failed to load dependencies, you may be using the Core version of the library. In that case, eithter turn off markdown and html parsing or provide your own parser and sanitizer"),t}}return class{constructor(e={}){if("undefined"==typeof document)throw new Error("TypeMorph requires a DOM environment");this.config={...t,...e},this.config.parent&&this._setParent(this.config.parent),this.config.text&&this._setText(this.config.text),this.config.scrollContainer&&this._setScrollContainer(this.config.scrollContainer),this.speed=this.config.speed,this.backspaceSpeed=this.config.backspaceSpeed,this.cursorChar=this.config.cursorChar,this.chunkSize=this.config.chunkSize,this.scrollInterval=this.config.scrollInterval,this._currentLoop=0,this._cursorEl=null,this._abortController=null,this._destroyed=!1,this._isTyping=!1,this._operationQueue=Promise.resolve(),this._activeTimers=new Set,this._userScrolled=!1,this._scrollListener=null,this._validateOptions(this.config)}async type(t,e=null,r={}){this._checkLifetime();const{_parent:o,_options:n}=this._readOptions(e,r);return this._validateOptions(n),await this._cancelCurrentOperation(n),this._startOperation(async e=>{this._createCursor(n),await this._type(t,o,{...n,loopSource:!1},e)})}async stop(){this._checkLifetime(),await this._cancelCurrentOperation(),await e(this.config.onStop,this)}async loop(t=null,e=null,r={}){this._checkLifetime();const{_parent:o,_options:n}=this._readOptions(e,r);return this._validateOptions(n),await this._cancelCurrentOperation(n),this._startOperation(async e=>{await this._loop(t,o,e,n)})}async backspace(t=null,e=null,r={}){this._checkLifetime();const{_parent:o,_options:n}=this._readOptions(e,r);this._validateOptions(n);const i=this._resolveParent(o);if(n.scrollContainer=this._getScrollContainer(i,n),this._setupScrollTracking(n.scrollContainer),null!=t&&("number"!=typeof t||t<0))throw new Error("TypeMorph: count has to be a number >= 0");return await this._cancelCurrentOperation(n),this._startOperation(async e=>{this._createCursor(n);try{this._isTyping=!0,await this._backspaceContent(i,i,e,{...n,maxDeleteCount:t})}finally{this._isTyping=!1,e.aborted||await this._onFinish(n)}})}destroy(){this._destroyed||(this.stop(),this._abortController=null,this._removeCursor(),this._clearScrollListener(),this._destroyed=!0,e(this.config.onDestroy,this))}isTyping(){return this._isTyping}isDestroyed(){return this._destroyed}getCurrentLoop(){return this._currentLoop}async _loop(t,e,r,o){this._createCursor(o),this._currentLoop=0,this._isTyping=!0;const n=this._resolveParent(e),i=this._resolveText(t),s=o?.clearBeforeTyping??this.config.clearBeforeTyping,l=o?.loopStartDelay??this.config.loopStartDelay,a=o?.loopEndDelay??this.config.loopEndDelay,c=o?.loopType??this.config.loopType,h=o?.loopCount??this.config.loopCount,p=o?.loopFinalBehavior??this.config.loopFinalBehavior;o.scrollContainer=this._getScrollContainer(n,o),s&&this._clearContent(n),this._setupScrollTracking(o.scrollContainer);try{do{const t=this._currentlyLooping(n)&&this._currentLoop<h-1,e=this._currentlyLooping(n)&&this._currentLoop+1>=h;if(this._currentlyLooping(n)&&this._currentLoop>0&&l&&await this._delay(l,r),await this._type(i,n,{...o,loopSource:!0},r),r.aborted)break;const s=this._currentlyLooping(n)&&(t||e&&"remove"===p);s&&a&&await this._delay(a,r),s&&("clear"===c?this._clearContent(n):await this._backspaceContent(n,n,r,{...o,maxDeleteCount:null})),this._currentLoop++}while(this._currentlyLooping(n)&&this._currentLoop<h&&!r.aborted);r.aborted||await this._onFinish(o)}finally{this._isTyping=!1}}async _type(t,e,r,n){const i=r.loopSource?e:this._resolveParent(e),s=r.loopSource?t:this._resolveText(t);r.scrollContainer=r.loopSource?r.scrollContainer:this._getScrollContainer(i,r),r.loopSource||this._setupScrollTracking(r.scrollContainer),this._isTyping=!0;const l=r?.parseMarkdown??this.config.parseMarkdown,a=r?.parseHtml??this.config.parseHtml,c=r?.clearBeforeTyping??this.config.clearBeforeTyping,h=r?.markdownInline??this.config.markdownInline,p=r?.markdownParse??this.config.markdownParse;!c||r?.loopSource||n.aborted||this._clearContent(i);try{let t=s;if(l){const e=h?"parseInline":"parse",r=p?p(t,h):(await o()).marked[e](t);t=r instanceof Promise?await r:r}a||l?await this._typeHTML(t,i,n,r):await this._typeText(t,i,n,r),r?.loopSource||n.aborted||await this._onFinish(r)}finally{r?.loopSource||(this._isTyping=!1)}}_createCursor(t={}){const e=t?.showCursor??this.config.showCursor,r=t?.cursorChar??this.cursorChar;e?this._cursorEl?this._cursorEl.textContent=r:(this._cursorEl=document.createElement("span"),this._cursorEl.textContent=r,this._cursorEl.className="typemorph-cursor",this._cursorEl.setAttribute("data-typemorph-cursor","true")):this._removeCursor()}async _typeHTML(t,e,r,n){const i=n?.htmlSanitize??this.config.htmlSanitize,s=i?i(t):(await o()).DOMPurify.sanitize(t);t=s instanceof Promise?await s:s;const l=(new DOMParser).parseFromString(t,"text/html");await this._typeNode(e,l.body,r,n)}async _typeNode(t,e,r,o){const n=Array.from(e.childNodes);for(let e of n){if(r.aborted||!this._parentStillExists(t))break;if(e.nodeType===Node.TEXT_NODE&&e.textContent.trim().length>0)await this._typeText(e.textContent,t,r,o);else if(e.nodeType===Node.ELEMENT_NODE){const n=document.createElement(e.tagName);for(let t of e.attributes)try{n.setAttribute(t.name,t.value)}catch(e){console.warn("TypeMorph: Failed to set attribute",t.name,e)}t.appendChild(n),await this._typeNode(n,e,r,o)}}}async _typeText(t,e,r,o){if(!t||r.aborted||!this._parentStillExists(e))return;this._cursorEl&&(this._cursorEl.parentNode&&this._cursorEl.remove(),e.appendChild(this._cursorEl));const n=Array.from(t);let i="",s=0;const l=o?.speed??this.speed,a=o?.autoScroll??this.config.autoScroll,c=o?.scrollInterval??this.scrollInterval,h=o?.chunkSize??this.chunkSize;for(let t=0;t<n.length&&(!r.aborted&&this._parentStillExists(e));t++){i+=n[t];const p=i.length>=h||t===n.length-1;p&&(this._appendTextToParent(e,i),i="",s++,a&&s>=c&&(this._scrollToEnd(o.scrollContainer),s=0)),this._parentStillExists(e)&&p&&await this._delay(l,r)}a&&this._scrollToEnd(o.scrollContainer)}_appendTextToParent(t,e){if(this._parentStillExists(t))if(this._cursorEl){let r=this._cursorEl.previousSibling;if(r&&r.nodeType===Node.TEXT_NODE)r.textContent+=e;else{const r=document.createTextNode(e);t.insertBefore(r,this._cursorEl)}}else if(t.lastChild&&t.lastChild.nodeType===Node.TEXT_NODE)t.lastChild.textContent+=e;else{const r=document.createTextNode(e);t.appendChild(r)}}async _onFinish(t){this._clearCursorIfNeeded(t),await e(t?.onFinish??this.config.onFinish,this)}_clearContent(t){t.innerHTML="",this._cursorEl&&t.appendChild(this._cursorEl)}_clearCursorIfNeeded(t={}){(t?.hideCursorOnFinishTyping??this.config.hideCursorOnFinishTyping)&&this._removeCursor()}_removeCursor(){this._cursorEl&&(this._cursorEl.remove(),this._cursorEl=null)}async _backspaceContent(t,e,r,o,n={}){if(r.aborted||!this._parentStillExists(t))return;const i=Array.from(e.childNodes);for(let e=i.length-1;e>=0;e--){const s=i[e];if(r.aborted||!this._parentStillExists(t))return;if(!this._cursorEl||s!==this._cursorEl)if(s.nodeType===Node.TEXT_NODE){const{currentRemainingCharCount:e}=await this._backspaceTextNode(s,t,r,o,n);if(n.currentRemainingCharCount=e,null!=o.maxDeleteCount&&n.charDeleteCount>=o.maxDeleteCount)break}else if(s.nodeType===Node.ELEMENT_NODE){await this._backspaceContent(t,s,r,o,n);const e=null!=o.maxDeleteCount&&n.charDeleteCount>=o.maxDeleteCount;if(r.aborted||(e&&0!==n.currentRemainingCharCount||(s.parentNode.removeChild(s),n.currentRemainingCharCount=null),this._cursorEl&&this._appendCursorToLastTextNode(t)),e)break}}}_appendCursorToLastTextNode(t){const e=this._findLastTextNode(t);e&&e.parentNode?e.parentNode.appendChild(this._cursorEl):t.appendChild(this._cursorEl)}_findLastTextNode(t){const e=Array.from(t.childNodes);for(let t=e.length-1;t>=0;t--){const r=e[t];if(r!=this._cursorEl)if(r.nodeType===Node.TEXT_NODE){if(r.textContent&&r.textContent.trim().length>0)return r}else if(r.nodeType===Node.ELEMENT_NODE){const t=this._findLastTextNode(r);if(t)return t}}return null}async _backspaceTextNode(t,e,r,o,n){const i=Array.from(t.textContent);null==n.charDeleteCount&&(n.charDeleteCount=0);let s=i.length,l=0;if(0===o.maxDeleteCount)return{currentRemainingCharCount:s};const a=o?.chunkSize??this.config.chunkSize,c=o?.autoScroll??this.config.autoScroll;for(let h=i.length-1;h>=0&&(!r.aborted&&this._parentStillExists(e));h-=a){const p=Math.max(0,h-a+1),u=i.slice(0,p),d=o?.scrollInterval??this.scrollInterval,_=o?.backspaceSpeed??this.backspaceSpeed;if(t.textContent=u.join(""),n.charDeleteCount+=h-p+1,s=Math.max(0,s-a),l++,c&&l>=d&&(t.parentNode&&this._scrollToEnd(o.scrollContainer),l=0),this._parentStillExists(e)&&await this._delay(_,r),null!=o.maxDeleteCount&&n.charDeleteCount>=o.maxDeleteCount)break}return this._parentStillExists(e)&&t.parentNode&&!t.textContent&&t.parentNode.removeChild(t),c&&this._parentStillExists(e)&&t.parentNode&&this._scrollToEnd(o.scrollContainer),{currentRemainingCharCount:s}}_resolveParent(t=null){return this._validateElement(t??this.parent)}_getScrollContainer(t,e){return e?.scrollContainer&&this._validateElement(e.scrollContainer),this.scrollContainer??t}_setParent(t){this.parent=this._validateElement(t)}_setScrollContainer(t){this.scrollContainer=this._validateElement(t)}_validateElement(t){const e=this._getElement(t),r=e instanceof Element;if(!e||!r)throw"string"==typeof t?new Error(`TypeMorph: Element not found for selector #${t}`):new Error("TypeMorph: Element is not a valid HTML element or element ID");return e}_getElement(t){return"string"==typeof t?document.getElementById(t):t}_resolveText(t=null){return this._validateText(t??this.text)}_setText(t){this.text=this._validateText(t)}_validateText(t){if(null==t)throw new Error("[TypeMorph] Please provide a valid text");return"string"!=typeof t&&(console.warn(`[TypeMorph] Non-string input (${typeof t}) auto-converted to string.`),t=String(t)),t}_currentlyLooping(t){return this._isTyping&&this._parentStillExists(t)}_checkLifetime(){if(this._destroyed)throw new Error("TypeMorph: Cannot call method on destroyed instance")}async _delay(t,e){return new Promise(r=>{const o=setTimeout(()=>{this._activeTimers.delete(o),r()},t);this._activeTimers.add(o),e.addEventListener("abort",()=>{clearTimeout(o),this._activeTimers.delete(o),r()},{once:!0})})}async _startOperation(t){this._abortController&&this._abortController.abort();const e=new AbortController;return this._abortController=e,this._operationQueue=(async()=>{try{await t(e.signal)}catch(t){if("AbortError"!==t.name)throw t}finally{this._abortController===e&&(this._abortController=null),this._clearScrollListener()}})(),this._operationQueue}async _cancelCurrentOperation(t={}){if(this._abortController&&this._abortController.abort(),this._operationQueue)try{await this._operationQueue}catch{}this._isTyping=!1,this._clearCursorIfNeeded(t),this._clearScrollListener()}_parentStillExists(t){return t&&t.isConnected}_validateOptions(t){if(t){if(null!=t.chunkSize&&"number"!=typeof t.chunkSize||t.chunkSize<1)throw new Error("TypeMorph: chunkSize has to be a number > 0");if(null!=t.loopCount&&"number"!=typeof t.loopCount||t.loopCount<0)throw new Error("TypeMorph: loopCount has to be a number >= 0");if(null!=t.speed&&"number"!=typeof t.speed||t.speed<0)throw new Error("TypeMorph: speed has to be a number >= 0");if(null!=t.backspaceSpeed&&"number"!=typeof t.backspaceSpeed||t.backspaceSpeed<0)throw new Error("TypeMorph: backspaceSpeed has to be a number >= 0")}}_readOptions(t,e){return t&&"object"==typeof t&&!("nodeType"in t)&&(e=t,t=null),{_parent:t,_options:e}}_scrollToEnd(t){t.scrollHeight<=t.clientHeight||this._userScrolled||(this.config.smoothScroll?t.scrollTo({top:t.scrollHeight-t.clientHeight,behavior:"smooth"}):t.scrollTop=t.scrollHeight-t.clientHeight)}_setupScrollTracking(t){this._clearScrollListener();const e=()=>{const e=t.scrollHeight-t.scrollTop-t.clientHeight;this._userScrolled=e>0};t.addEventListener("scroll",e,{passive:!0}),this._scrollListener={element:t,handler:e}}_clearScrollListener(){this._scrollListener&&(this._scrollListener.element.removeEventListener("scroll",this._scrollListener.handler),this._scrollListener=null),this._userScrolled=!1}}});
//# sourceMappingURL=typemorph.core.umd.min.js.map
